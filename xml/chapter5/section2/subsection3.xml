<SUBSECTION>
  <NAME>
    Generating Execution
    <SPLITINLINE>
      <SCHEME>Procedures</SCHEME>
      <JAVASCRIPT>Functions</JAVASCRIPT>
    </SPLITINLINE>
    for Instructions
  </NAME>

  <LABEL NAME="sec:ex-proc"/>
  <INDEX>execution
  <SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SUBINDEX>in register-machine simulator|(</SUBINDEX></INDEX>

  <TEXT>
    The assembler calls
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-execution-procedure</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>make_execution_function</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to generate the execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for an instruction.
    Like the <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    in the evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/>,
    this dispatches on the type of instruction to generate the appropriate
    execution
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
      <JAVASCRIPT>function.</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>make_execution_function</NAME>
      <REQUIRES>make_assign</REQUIRES>
      <REQUIRES>make_test</REQUIRES>
      <REQUIRES>make_branch_5</REQUIRES>
      <REQUIRES>make_go_to</REQUIRES>
      <REQUIRES>make_save</REQUIRES>
      <REQUIRES>make_perform</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
      <!--  \indcode*{make-execution-procedure} -->
(define (make-execution-procedure inst labels machine
                                  pc flag stack ops)
  (cond ((eq? (car inst) 'assign)
         (make-assign inst machine labels ops pc))
        ((eq? (car inst) 'test)
         (make-test inst machine labels ops flag pc))
        ((eq? (car inst) 'branch)
         (make-branch inst machine labels flag pc))
        ((eq? (car inst) 'goto)
         (make-goto inst machine labels pc))
        ((eq? (car inst) 'save)
         (make-save inst machine stack pc))
        ((eq? (car inst) 'restore)
         (make-restore inst machine stack pc))
        ((eq? (car inst) 'perform)
         (make-perform inst machine labels ops pc))
        (else (error "Unknown instruction type - - ASSEMBLE"
                     inst))))
      </SCHEME>
      <JAVASCRIPT>
function make_execution_function(inst, labels, machine, 
                                 pc, flag, stack, ops) {
    return head(inst) === "assign"
        ? make_assign(inst, machine, labels, ops, pc)
        : head(inst) === "test"
        ? make_test(inst, machine, labels, ops, flag, pc)
        : head(inst) === "branch"
        ? make_branch(inst, machine, labels, flag, pc)
        : head(inst) === "go_to"
        ? make_go_to(inst, machine, labels, pc)
        : head(inst) === "save"
        ? make_save(inst, machine, stack, pc)
        : head(inst) === "restore"
        ? make_restore(inst, machine, stack, pc)
        : head(inst) === "perform"
        ? make_perform(inst, machine, labels, ops, pc)
        : error(inst, "Unknown instruction type in assemble:");
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    For each type of instruction in the register-machine language, there
    is a generator that builds an appropriate execution
    <SPLITINLINE>
      <SCHEME>procedure.</SCHEME>
    <JAVASCRIPT>function.</JAVASCRIPT></SPLITINLINE>
    The details of these
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    determine both the syntax and meaning of the individual instructions in the
    register-machine language. We use data abstraction to isolate the detailed
    syntax of register-machine expressions from the general execution mechanism,
    as we did for evaluators in
    section<SPACE/><REF NAME="sec:representing-expressions"/>, by using syntax
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to extract and classify the parts of an instruction.
  </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME><SCHEMEINLINE>Assign</SCHEMEINLINE> instructions</SCHEME>
	<JAVASCRIPT>The instruction <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <!-- \indcodeplus{assign}{(in register machine)}[simulating]-->
  <TEXT>
    The
    <SPLITINLINE>
      <SCHEME>make-assign</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_assign</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    handles
    <SPLITINLINE>
      <SCHEME>assign</SCHEME>
      <JAVASCRIPT>assign</JAVASCRIPT>
    </SPLITINLINE>
    instructions:
    <!--  \indcode*{make-assign} -->
    <SNIPPET>
      <NAME>make_assign</NAME>
      <REQUIRES>assign_reg_name</REQUIRES>
      <REQUIRES>make_operation_exp</REQUIRES>
      <REQUIRES>assign_constructor</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-assign inst machine labels operations pc)
  (let ((target
         (get-register machine (assign-reg-name inst)))
        (value-exp (assign-value-exp inst)))
    (let ((value-proc
           (if (operation-exp? value-exp)
               (make-operation-exp
                value-exp machine labels operations)
               (make-primitive-exp
                (car value-exp) machine labels))))
      (lambda ()     ; execution procedure for assign
        (set-contents! target (value-proc))
        (advance-pc pc)))))
      </SCHEME>
      <JAVASCRIPT>
function make_assign(inst, machine, labels, operations, pc) {
    const target = get_register(machine, assign_reg_name(inst));
    const value_exp = assign_value_exp(inst);
    const value_fun =
        is_operation_exp(value_exp)
        ? make_operation_exp(value_exp, machine, labels, operations)
        : make_primitive_exp(value_exp, machine, labels);
    return () => {
        set_contents(target, value_fun());
        advance_pc(pc); 
    };
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-assign</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_assign</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    extracts the target register name (the second element of the instruction)
    and the value expression (the rest of the list that forms the instruction)
    from the <SCHEMEINLINE>assign</SCHEMEINLINE> instruction using the selectors
      <!--  \indcode*{assign-reg-name} -->
      <!--  \indcode*{assign-value-exp} -->
    <SNIPPET>
      <NAME>assign_reg_name</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (assign-reg-name assign-instruction)
  (cadr assign-instruction))

(define (assign-value-exp assign-instruction)
  (cddr assign-instruction))
      </SCHEME>
      <JAVASCRIPT>
function assign_reg_name(assign_instruction) {
    return head(tail(assign_instruction));
}
function assign_value_exp(assign_instruction) { 
    return head(tail(tail(assign_instruction)));
}
      </JAVASCRIPT>
    </SNIPPET>
    The function <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> is the matching
    constructor for <JAVASCRIPTINLINE>assign</JAVASCRIPTINLINE> instructions.
    <SNIPPET>
      <NAME>assign_constructor</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <JAVASCRIPT>
function assign(register_name, source) {
    return list("assign", register_name, source);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The register name is looked up with
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-register</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>get_register</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    to produce the target register object.  The value expression is passed to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-operation-exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_operation_exp</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    if the value is the result of an operation, and to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-primitive-exp</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>make_primitive_exp</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    otherwise.  These
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    (shown below) parse the value expression and produce an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for the value.  This is a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    of no arguments, called 
    <!--  \indcode{value-proc} -->
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>value-proc</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>value_fun</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    which will be evaluated during the simulation to produce the actual
    value to be assigned to the register.  Notice that the work of looking
    up the register name and parsing the value expression is performed
    just once, at assembly time, not every time the instruction is
    simulated.  This saving of work is the reason we use execution
    <INDEX>syntactic analysis, separated from execution
    <SUBINDEX>in register-machine simulator</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>functions,</JAVASCRIPT>
    </SPLITINLINE>
    and corresponds directly to the saving in work we obtained by separating
    program analysis from execution in the evaluator of
    section<SPACE/><REF NAME="sec:separating-analysis"/>.
  </TEXT>

  <TEXT>
    The result returned by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-assign</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_assign</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    is the execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for the <SCHEMEINLINE>assign</SCHEMEINLINE> instruction.  When this
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is called (by the machine model<APOS/>s <SCHEMEINLINE>execute</SCHEMEINLINE>
    <SPLITINLINE>
      <SCHEME>procedure),</SCHEME>
      <JAVASCRIPT>function),</JAVASCRIPT>
    </SPLITINLINE>
    it sets the contents of the target register to the result obtained by
    executing
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>value-proc</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>value_fun</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    Then it advances the <SCHEMEINLINE>pc</SCHEMEINLINE> to the next instruction
    by running the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
      <!--  \indcode*{advance-pc} -->
    <SNIPPET>
      <NAME>advance_pc</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (advance-pc pc)
  (set-contents! pc (cdr (get-contents pc))))
      </SCHEME>
      <JAVASCRIPT>
function advance_pc(pc) {
    set_contents(pc, tail(get_contents(pc))); 
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Advance-pc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>advance_pc</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    is the normal termination for all instructions except
    <SCHEMEINLINE>branch</SCHEMEINLINE> and <SCHEMEINLINE>goto</SCHEMEINLINE>.
  </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>
	  <SCHEMEINLINE>Test</SCHEMEINLINE>,
	  <SCHEMEINLINE>branch</SCHEMEINLINE>, and
	  <SCHEMEINLINE>goto</SCHEMEINLINE>
	  instructions
	</SCHEME>
	<JAVASCRIPT>
	  The instructions
	  <JAVASCRIPTINLINE>test</JAVASCRIPTINLINE>,
	  <JAVASCRIPTINLINE>branch</JAVASCRIPTINLINE>, and
	  <JAVASCRIPTINLINE>goto</JAVASCRIPTINLINE>
	</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    <!-- \indcodeplus{test}{(in register machine)}[simulating]-->
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Make-test</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	The function
	<JAVASCRIPTINLINE>make_test</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    handles <SCHEMEINLINE>test</SCHEMEINLINE> instructions in a similar way.
    It extracts the expression that specifies the condition to be tested and
    generates an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for it.  At simulation time, the
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for the condition is called, the result is assigned to the
    <SCHEMEINLINE>flag</SCHEMEINLINE> register, and the
    <SCHEMEINLINE>pc</SCHEMEINLINE> is advanced:
      <!--  \indcode*{make-test} -->
      <!--  \indcode*{test-condition} -->
    <SNIPPET>
      <NAME>make_test</NAME>
      <REQUIRES>advance_pc</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
        (let ((condition-proc
               (make-operation-exp
                condition machine labels operations)))
          (lambda ()
            (set-contents! flag (condition-proc))
            (advance-pc pc)))
        (error "Bad TEST instruction - - ASSEMBLE" inst))))

(define (test-condition test-instruction)
  (cdr test-instruction))
      </SCHEME>
      <JAVASCRIPT>
function make_test(inst, machine, labels, operations, flag, pc) {
    const condition = test_condition(inst);
    if (is_operation_exp(condition)) {
        const condition_fun = make_operation_exp(condition,
                                  machine, labels, operations);
        return () => {
                       set_contents(flag, condition_fun());
                       advance_pc(pc); 
                     };
    } else {
        error(inst, "Bad test instruction in assemble:");
    }
}
function test(sequence) {
    return list("test", sequence);
}
function test_condition(test_instruction) {
    return head(tail(test_instruction));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <!-- \indcodeplus{branch}{(in register machine)}[simulating]-->
    The execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for a <SCHEMEINLINE>branch</SCHEMEINLINE> instruction checks the contents of
    the <SCHEMEINLINE>flag</SCHEMEINLINE> register and either sets the contents
    of the <SCHEMEINLINE>pc</SCHEMEINLINE> to the branch destination (if the
    branch is taken) or else just advances the <SCHEMEINLINE>pc</SCHEMEINLINE>
    (if the branch is not taken).  Notice that the indicated destination in a
    <SCHEMEINLINE>branch</SCHEMEINLINE> instruction must be a label, and the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-branch</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_branch</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    enforces this.  Notice also that the label is looked up at assembly time,
    not each time the <SCHEMEINLINE>branch</SCHEMEINLINE> instruction is
    simulated.
      <!--  \indcode*{make-branch} -->
      <!--  \indcode*{branch-dest} -->
    <SNIPPET>
      <NAME>make_branch_5</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
        (let ((insts
               (lookup-label labels (label-exp-label dest))))
          (lambda ()
            (if (get-contents flag)
                (set-contents! pc insts)
                (advance-pc pc))))
        (error "Bad BRANCH instruction - - ASSEMBLE" inst))))

(define (branch-dest branch-instruction)
  (cadr branch-instruction))
      </SCHEME>
      <JAVASCRIPT>
function make_branch(inst, machine, labels, flag, pc) {
    const dest = branch_dest(inst);
    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));
        return () => {
                       if (get_contents(flag)) {
                           set_contents(pc, insts);
                       } else {
                           advance_pc(pc);
                       }
                     };
    } else {
        error(inst, "Bad branch instruction in assemble:");
    }
}
function branch(label) {
    return list("branch", label);
}
function branch_dest(branch_instruction) {
    return head(tail(branch_instruction));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <!-- \indcodeplus{goto}{(in register machine)}[simulating]-->
    A
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    instruction is similar to a branch, except that the destination may be
    specified either as a label or as a register, and there is no condition to
    check<EMDASH/>the <SCHEMEINLINE>pc</SCHEMEINLINE> is always set to the
    new destination.
      <!--  \indcode*{make-goto} -->
      <!--  \indcode*{goto-dest} -->
    <SNIPPET>
      <NAME>make_go_to</NAME>
      <REQUIRES>is_register_exp</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond ((label-exp? dest)
           (let ((insts
                  (lookup-label labels
                                (label-exp-label dest))))
             (lambda () (set-contents! pc insts))))
          ((register-exp? dest)
           (let ((reg
                  (get-register machine
                                (register-exp-reg dest))))
             (lambda ()
               (set-contents! pc (get-contents reg)))))
          (else (error "Bad GOTO instruction - - ASSEMBLE"
            inst)))))

(define (goto-dest goto-instruction)
  (cadr goto-instruction))
      </SCHEME>
      <JAVASCRIPT>
function make_go_to(inst, machine, labels, pc) {
    const dest = goto_dest(inst);
    if (is_label_exp(dest)) {
        const insts = lookup_label(labels, label_exp_label(dest));
        return () => set_contents(pc, insts);
    } else if (is_register_exp(dest)) {
        const reg = get_register(machine, register_exp_reg(dest));
        return () => set_contents(pc, get_contents(reg));
    } else {
        error(inst, "Bad go_to instruction in assemble:");
    }
}

function go_to(label) {
    return list("go_to", label);
}
function goto_dest(goto_instruction) {
    return head(tail(goto_instruction));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Other instructions</NAME>
  </SUBHEADING>

  <TEXT>
    The stack instructions
    <SCHEMEINLINE>save</SCHEMEINLINE> and <SCHEMEINLINE>restore</SCHEMEINLINE>
    simply use the stack with the designated register and advance the
    <SCHEMEINLINE>pc</SCHEMEINLINE>:
      <!-- \indcodeplus{save}{(in register machine)}[simulating]-->
      <!--  \indcode*{make-save} -->
      <!--  \indcode*{make-restore} -->
      <!-- \indcodeplus{restore}{(in register machine)}[simulating]-->
      <!--  \indcode*{stack-inst-reg-name} -->
    <SNIPPET>
      <NAME>make_save</NAME>
      <REQUIRES>pop</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-save inst machine stack pc)
  (let ((reg (get-register machine
              (stack-inst-reg-name inst))))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc))))

(define (make-restore inst machine stack pc)
  (let ((reg (get-register machine
              (stack-inst-reg-name inst))))
    (lambda ()
      (set-contents! reg (pop stack))    
      (advance-pc pc))))

(define (stack-inst-reg-name stack-instruction)
  (cadr stack-instruction))
      </SCHEME>
      <JAVASCRIPT>
function make_save(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));
    return () => {
                   push(stack, get_contents(reg));
                   advance_pc(pc);
                 };
}
function make_restore(inst, machine, stack, pc) {
    const reg = get_register(machine, stack_inst_reg_name(inst));
    return () => {
                   set_contents(reg, pop(stack));
                   advance_pc(pc); 
                 };
}

function save(reg) {
    return list("save", reg);
}
function restore(reg) {
    return list("restore", reg);
}
function stack_inst_reg_name(stack_instruction) {
    return head(tail(stack_instruction));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <!-- \indcodeplus{perform}{(in register machine)}[simulating]-->
    The final instruction type, handled by
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-perform</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>make_perform</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    generates an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for the action to be performed.  At simulation time, the action
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is executed and the <SCHEMEINLINE>pc</SCHEMEINLINE> advanced.
    <!--  \indcode*{make-perform} -->
    <!--  \indcode*{perform-action} -->
    <SNIPPET>
      <NAME>make_perform</NAME>
      <REQUIRES>is_operation_exp</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
        (let ((action-proc
               (make-operation-exp
                action machine labels operations)))
          (lambda ()
            (action-proc)
            (advance-pc pc)))
        (error "Bad PERFORM instruction - - ASSEMBLE" inst))))

(define (perform-action inst) (cdr inst))
      </SCHEME>
      <JAVASCRIPT>
function make_perform(inst, machine, labels, operations, pc) {
    const action = perform_action(inst);
    if (is_operation_exp(action)) {
        const action_fun = make_operation_exp(action, machine,
                                            labels, operations);
        return () => { 
                       action_fun(); advance_pc(pc); 
                     };
    } else {
        error(inst, "Bad perform instruction in assemble");
    }
}
function perform(action) {
    return list("perform", action);
}
function perform_action(inst) {
    return head(tail(inst)); 
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    for subexpressions</NAME>
  </SUBHEADING>

  <TEXT>
    <!-- \indcodeplus{reg}{(in register machine)}[simulating]-->
    <!-- \indcodeplus{label}{(in register machine)}[simulating]-->
    <!-- \indcodeplus{const}{(in register machine)}[simulating]-->
    The value of a <SCHEMEINLINE>reg</SCHEMEINLINE>,
    <SCHEMEINLINE>label</SCHEMEINLINE>, or
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>const</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>constant</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    expression may be needed for assignment to a register
    <SPLITINLINE>
      <SCHEME>(<SCHEMEINLINE>make-assign</SCHEMEINLINE>)</SCHEME>
      <JAVASCRIPT>(<JAVASCRIPTINLINE>make_assign</JAVASCRIPTINLINE>)</JAVASCRIPT>
    </SPLITINLINE>
    or for input to an operation
    <SPLITINLINE>
      <SCHEME>(<SCHEMEINLINE>make-operation-exp</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      (<JAVASCRIPTINLINE>make_operation_exp</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    below).  The following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    generates execution
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to produce values for these expressions during the simulation:
      <!--  \indcode*{make-primitive-exp} -->
    <SNIPPET>
      <NAME>make_primitive_exp</NAME>
      <REQUIRES>lookup_label</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-primitive-exp exp machine labels)
  (cond ((constant-exp? exp)
         (let ((c (constant-exp-value exp)))
           (lambda () c)))
        ((label-exp? exp)
         (let ((insts
                (lookup-label labels
                              (label-exp-label exp))))
           (lambda () insts)))
        ((register-exp? exp)
         (let ((r (get-register machine
                   (register-exp-reg exp))))
           (lambda () (get-contents r))))
        (else
         (error "Unknown expression type - - ASSEMBLE" exp))))
      </SCHEME>
      <JAVASCRIPT>
function make_primitive_exp(exp, machine, labels) {
    if (is_constant_exp(exp)) {
        const c = constant_exp_value(exp);
        return () => c;
    } else if (is_label_exp(exp)) {
        const insts = lookup_label(labels, label_exp_label(exp));
        return () => insts;
    } else if (is_register_exp(exp)) {
        const r = get_register(machine, register_exp_reg(exp));
        return () => get_contents(r); 
    } else {
        error(exp, "Unknown expression type in assemble:");
    }
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The syntax of
    <SCHEMEINLINE>reg</SCHEMEINLINE>, <SCHEMEINLINE>label</SCHEMEINLINE>, and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>const</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>constant</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    expressions is determined by
      <!--  \indcode*{register-exp} -->
      <!--  \indcode*{register-exp-reg} -->
      <!--  \indcode*{constant-exp} -->
      <!--  \indcode*{constant-exp-value} -->
      <!--  \indcode*{label-exp} -->
      <!--  \indcode*{label-exp-label} -->
    <SNIPPET>
      <NAME>is_register_exp</NAME>
      <REQUIRES>tagged_list</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (register-exp? exp) (tagged-list? exp 'reg))

(define (register-exp-reg exp) (cadr exp))

(define (constant-exp? exp) (tagged-list? exp 'const))

(define (constant-exp-value exp) (cadr exp))

(define (label-exp? exp) (tagged-list? exp 'label))

(define (label-exp-label exp) (cadr exp))
      </SCHEME>
      <JAVASCRIPT>
function reg(name) {
    return list("reg", name);
}
function is_register_exp(exp) {
    return is_tagged_list(exp, "reg");
}
function register_exp_reg(exp) {
    return head(tail(exp));
}
function constant(value) {
    return list("constant", value);
}
function is_constant_exp(exp) {
    return is_tagged_list(exp, "constant");
}
function constant_exp_value(exp) {
    return head(tail(exp));
}
function label(name) {
    return list("label", name);
}
function is_label_exp(exp) {
    return is_tagged_list(exp, "label");
}
function label_exp_label(exp) {
    return head(tail(exp));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <!--  \indcodeplus{op}{(in register machine)}[simulating]-->
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Assign</SCHEMEINLINE>,
	<SCHEMEINLINE>perform</SCHEMEINLINE>, and
	<SCHEMEINLINE>test</SCHEMEINLINE>
	instructions
      </SCHEME>
      <JAVASCRIPT>
	Instructions
	<SCHEMEINLINE>assign</SCHEMEINLINE>,
	<SCHEMEINLINE>perform</SCHEMEINLINE>, and
	<SCHEMEINLINE>test</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    may include the application of a machine operation (specified by
    an <SCHEMEINLINE>op</SCHEMEINLINE> expression) to some operands (specified
    by <SCHEMEINLINE>reg</SCHEMEINLINE> and
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>const</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>constant</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    expressions). The following
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    produces an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for an <QUOTE>operation expression</QUOTE><EMDASH/>a list containing the
    operation and operand expressions from the instruction:
      <!--  \indcode*{make-operation-exp} -->
    <SNIPPET>
      <NAME>make_operation_exp</NAME>
      <REQUIRES>lookup_prim</REQUIRES>
      <REQUIRES>make_primitive_exp</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
        (aprocs
         (map (lambda (e)
                (make-primitive-exp e machine labels))
              (operation-exp-operands exp))))
    (lambda ()
      (apply op (map (lambda (p) (p)) aprocs)))))
      </SCHEME>
      <JAVASCRIPT>
function make_operation_exp(exp, machine, labels, operations) {
    const op = lookup_prim(operation_exp_op(exp), operations);
    const aprocs = map(e => make_primitive_exp(e, machine, labels),
                       operation_exp_operands(exp));
    return () => apply_in_underlying_javascript(
                     op, map(p => p(), aprocs));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    The syntax of operation expressions is determined by
      <!--  \indcode*{operation-exp} -->
      <!--  \indcode*{operation-exp-op} -->
      <!--  \indcode*{operation-exp-operands} -->
    <SNIPPET>
      <NAME>is_operation_exp</NAME>
      <REQUIRES>tagged_list</REQUIRES>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (operation-exp? exp)
  (and (pair? exp) (tagged-list? (car exp) 'op)))

(define (operation-exp-op operation-exp)
  (cadr (car operation-exp)))

(define (operation-exp-operands operation-exp)
  (cdr operation-exp))
      </SCHEME>
      <JAVASCRIPT>
function op(name) {
    return list("op", name);
}
function is_operation_exp(exp) {
    return is_pair(exp) &amp;&amp; is_tagged_list(head(exp), "op");
}
function operation_exp_op(operation_exp) {
    return head(tail(head(operation_exp)));
}
function operation_exp_operands(operation_exp) {
    return tail(operation_exp);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Observe that the treatment of operation expressions is very much like
    the treatment of
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    applications by the
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>analyze-application</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_application</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    in the evaluator of section<SPACE/><REF NAME="sec:separating-analysis"/> in
    that we generate an execution
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    for each operand.  At simulation time, we call the operand
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    and apply the Scheme
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    that simulates the operation to the resulting values. The simulation
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>function</JAVASCRIPT>
    </SPLITINLINE>
    is found by looking up the operation name in the operation table for the
    machine:
      <!--  \indcode*{lookup-prim} -->
    <SNIPPET>
      <NAME>lookup_prim</NAME>
      <EXAMPLE>gcd_machine_complete_example</EXAMPLE>
      <SCHEME>
(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
        (cadr val)
        (error "Unknown operation - - ASSEMBLE" symbol))))
      </SCHEME>
      <JAVASCRIPT>
function lookup_prim(symbol, operations) {
    const val = assoc(symbol, operations);
    return val === undefined
        ? error(symbol, "Unknown operation in assemble:")
        : head(tail(val));
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    The treatment of machine operations above permits them to operate
    on labels as well as on constants and the contents of registers.
    Modify the expression-processing
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    to enforce the condition that operations can be used only with registers
    and constants.
  </EXERCISE>

  <EXERCISE>
    Design a new syntax for register-machine instructions and modify the
    simulator to use your new syntax.  Can you implement your new
    syntax without changing any part of the simulator except the
    syntax
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>functions</JAVASCRIPT>
    </SPLITINLINE>
    in this section?
    <LABEL NAME="ex:reg-machine-syntax"/>
  </EXERCISE>

  <EXERCISE>
    <!-- \indcodeplus{restore}{(in register machine)}-->
    <!-- \indcodeplus{save}{(in register machine)}-->
    When we introduced <SCHEMEINLINE>save</SCHEMEINLINE> and
    <SPLITINLINE>restore</SPLITINLINE> in
    section<SPACE/><REF NAME="sec:stack-recursion"/>, we didn<APOS/>t specify
    what would happen if you tried to restore a register that was not the last
    one saved, as in the sequence
    <SNIPPET EVAL="no">
      <SCHEME>
(save y)
(save x)
(restore y)
      </SCHEME>
      <JAVASCRIPT>
save(y);
save(x);
restore(y);
      </JAVASCRIPT>
    </SNIPPET>
    There are several reasonable possibilities for the meaning of
    <SCHEMEINLINE>restore</SCHEMEINLINE>:
    <OL>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(restore y)</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>restore(y)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	puts into <SCHEMEINLINE>>y</SCHEMEINLINE> the last value saved on the
	stack, regardless of what register that value came from.  This is the
	way our simulator behaves.  Show how to take advantage of this
	behavior to eliminate one instruction from the Fibonacci machine of
	section<SPACE/><REF NAME="sec:stack-recursion"/>
	(figure<SPACE/><REF NAME="fig:fib-machine"/>).
      </LI>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(restore y)</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>restore(y)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	puts into <SCHEMEINLINE>y</SCHEMEINLINE> the last value saved on the
	stack, but only if that value was saved from
	<SCHEMEINLINE>y</SCHEMEINLINE>; otherwise, it signals an error.  Modify
	the simulator to behave this way.  You will have to change
	<SCHEMEINLINE>save</SCHEMEINLINE> to put the register name on the stack
	along with the value.
      </LI>
      <LI>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(restore y)</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>restore(y)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	puts into <SCHEMEINLINE>y</SCHEMEINLINE> the last value saved from
	<SCHEMEINLINE>y</SCHEMEINLINE> regardless of what other registers were
	saved after <SCHEMEINLINE>y</SCHEMEINLINE> and not restored.  Modify the
	simulator to behave this way.  You will have to associate a separate
	stack with each register.  You should make the
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>initialize-stack</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>initialize_stack</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	operation initialize all the register stacks.
      </LI>
    </OL>
    <LABEL NAME="ex:stack-behavior"/>
  </EXERCISE>

  <EXERCISE>
    The simulator can be used to help determine the data paths required
    for implementing a machine with a given controller.  Extend
    the assembler to store the following information in the machine model:
    <UL>
      <LI>
	a list of all instructions, with duplicates removed, sorted by
	instruction type
	(<SCHEMEINLINE>assign</SCHEMEINLINE>,
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE>,</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE>,</JAVASCRIPT>
	</SPLITINLINE>
	and so on);
      </LI>
      <LI>
	a list (without duplicates) of the registers used to hold entry points
	(these are the registers referenced by
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>goto</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>go_to</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	instructions);
      </LI>
      <LI>
	a list (without duplicates) of the registers that are
	<SCHEMEINLINE>save</SCHEMEINLINE>d
	or <SCHEMEINLINE>restore</SCHEMEINLINE>d;
      </LI>
      <LI>
	for each register, a list (without duplicates) of the sources from
	which it is assigned (for example, the sources for register
	<SCHEMEINLINE>val</SCHEMEINLINE> in the factorial machine of
	figure<SPACE/><REF NAME="fig:fact-machine"/> are
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(const 1)</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>constant(1)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	and
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>((op *) (reg n) (reg val))</SCHEMEINLINE>).
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>op("*", reg("n"), reg("val"))</JAVASCRIPTINLINE>).
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
    </UL>
    Extend the message-passing interface to the machine to provide access to
    this new information.  To test your analyzer, define the Fibonacci machine
    from figure<SPACE/><REF NAME="fig:fib-machine"/> and examine the lists you
    constructed.
    <LABEL NAME="ex:simulated-data-paths"/>
  </EXERCISE>

  <EXERCISE>
    Modify the simulator so that it uses the controller sequence to determine
    what registers the machine has rather than requiring a list of registers as
    an argument to
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-machine</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>make_machine</JAVASCRIPTINLINE>.</JAVASCRIPT>
    </SPLITINLINE>
    Instead of pre-allocating the registers in
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>make-machine</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>make_machine</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    you can allocate them one at a time when they are first seen during assembly
    of the instructions.
  </EXERCISE>
  <INDEX>execution
  <SPLITINLINE><SCHEME>procedure</SCHEME>
  <JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE>
  <SUBINDEX>in register-machine simulator|)</SUBINDEX></INDEX>
</SUBSECTION>
